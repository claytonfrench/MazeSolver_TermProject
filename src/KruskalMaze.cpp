#include <algorithm>
#include <iostream>
#include <random>
#include <ctime>
#include "KruskalMaze.h"

/**
 * @brief creates a maze of specified dimensions generated by a
 * randomized version of Kruskal's algorithm
 * @param w is the number of tiles per row
 * @param h is the number of rows
 */
KruskalMaze::KruskalMaze(int w, int h)
	: Maze(w, h)
{
	// Creates disjoint set with w*h initial disjoint sets
	set = DisjointSet(w*h);

	// Takes tiles in grid and connects each adjacent tiles by an undirected edge e
	for (int i=0; i < height; i++) {
		for (int j=0; j < width; j++) {

			MazeTile *cur = grid[i][j];

			if (i > 0) {
				MazeTile *adj = grid[i-1][j];
				Pair e = {cur, adj};
				edges.push_back(e);
			}

			if (i + 1 < height) {
				MazeTile *adj = grid[i+1][j];
				Pair e = {cur, adj};
				edges.push_back(e);
			}

			if (j > 0) {
				MazeTile *adj = grid[i][j-1];
				Pair e = {cur, adj};
				edges.push_back(e);
			}

			if (j + 1 < width) {
				MazeTile *adj = grid[i][j+1];
				Pair e = {cur, adj};
				edges.push_back(e);
			}
		}
	}

	// generates the maze
	generate();
}


/**
 * @brief generates a maze using a randomized Kruskal's algorithm
 * @return void
 */
void KruskalMaze::generate()
{
	srand(time(NULL));

	// Gets pairs of tiles (edges) and combines their respective sets until only
	// one set is left over
	while (set.size() > 1)
	{
		random_shuffle(edges.begin(), edges.end());
		Pair e = edges[0];
		MazeTile *u = e.u;
		MazeTile *v = e.v;

		int m = u->x*width + u->y;
		int n = v->x*width + v->y;

		if (set.combine(m, n))
		{
			remove_wall(u, v);
			edges.erase(edges.begin());
		}
	}
}
